services:
  db:
    image: postgres:15-alpine  # alpine меньше по размеру
    container_name: drf_psql
    restart: unless-stopped
    volumes:
      - postgres_data:/var/lib/postgresql/data
      # - ./init.sql:/docker-entrypoint-initdb.d/init.sql  # опционально
    # environment:
    #   POSTGRES_USER: blog_user
    #   POSTGRES_PASSWORD: ${DB_PASSWORD}
    #   POSTGRES_DB: blog_db
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U blog_user"]
      interval: 10s
      timeout: 5s
      retries: 5
    networks:
      - backend

  web:
    # build:
    #   context: .
    #   dockerfile: ./Dockerfile.prod
    image: ${IMAGE_NAME}
    container_name: drf_web
    restart: unless-stopped
    command: >
      sh -c "python manage.py migrate &&
             python manage.py collectstatic --noinput &&
             gunicorn drf_blog_api.wsgi:application --bind 0.0.0.0:8000 --workers 3 --threads 2"
    # Меняем порт на стандартный для Django
    ports:
      - "127.0.0.1:8000:8000"  # ⚠️ ТОЛЬКО localhost, не наружу!
    # environment:
      # Передаем все через .env файл
      # DB_NAME: blog_db  # Явно указываем
      # DB_USER: blog_user  # Явно указываем
      # DB_PASSWORD: ${DB_PASSWORD}  # Из .env
      # DB_HOST: db
      # DB_PORT: 5432
    # env_file:
      # - .env  # или .env.production
    depends_on:
      db:
        condition: service_healthy
    volumes:
      - static_volume:/app/staticfiles  # для Nginx
      - media_volume:/app/media  # если есть медиа
      - /opt/drf_blog_api/.env:/app/.env:ro
    # healthcheck:
    #   test: ["CMD", "curl", "-f", "http://localhost:8000/health/"]  # нужно создать endpoint
    #   interval: 30s
    #   timeout: 10s
    #   retries: 3
    #   start_period: 40s
    networks:
      - backend
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"

  # Опционально: Redis для кэша (если нужно)
  redis:
    image: redis:7-alpine
    restart: unless-stopped
    command: redis-server --appendonly yes
    volumes:
      - redis_data:/data
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5
    networks:
      - backend

volumes:
  postgres_data:
    driver: local
  static_volume:
    driver: local
  media_volume:
    driver: local
  redis_data:
    driver: local

networks:
  backend:
    driver: bridge
